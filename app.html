<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Awards Form</title>
  <style>
    :root{
      --bg0:#050512;
      --bg1:#03020a;
      --fg:#ffffff;
      --muted:rgba(255,255,255,.65);
      --muted2:rgba(255,255,255,.45);
      --card:rgba(255,255,255,.06);
      --card2:rgba(0,0,0,.25);
      --border:rgba(255,255,255,.12);
      --fuchsia: rgba(255,0,170,1);
      --cyan: rgba(0,200,255,1);
      --violet: rgba(140,60,255,1);
      --shadow: 0 0 20px rgba(255,0,170,.35), 0 0 60px rgba(0,200,255,.20);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--fg);
      background:
        radial-gradient(900px 500px at 15% 10%, rgba(255,0,170,.35), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(0,200,255,.25), transparent 60%),
        radial-gradient(1100px 700px at 60% 90%, rgba(140,60,255,.22), transparent 60%),
        linear-gradient(180deg, #070716 0%, #04030d 60%, #020208 100%);
      overflow-x:hidden;
    }

    /* neon scrollbar */
    ::-webkit-scrollbar{ width:10px; height:10px; }
    ::-webkit-scrollbar-thumb{
      background: linear-gradient(180deg, rgba(255,0,170,.7), rgba(0,200,255,.7));
      border-radius:999px;
    }
    ::-webkit-scrollbar-track{ background: rgba(255,255,255,.06); }

    a{ color:inherit; }
    button{ font:inherit; color:inherit; }

    .wrap{ max-width:1100px; margin:0 auto; padding:28px 16px 60px; }
    .header{
      display:flex; gap:12px; align-items:center; margin-bottom:18px;
    }
    .logo{
      width:38px; height:38px; border-radius:16px;
      background: linear-gradient(135deg, rgba(255,0,170,.9), rgba(0,200,255,.9));
      box-shadow: var(--shadow);
    }
    h1{
      margin:0;
      font-size: clamp(26px, 4vw, 40px);
      letter-spacing:-0.02em;
      text-shadow: 0 0 12px rgba(255,0,170,.45);
    }
    .subtitle{ margin:8px 0 0; color:var(--muted); max-width:70ch; line-height:1.4; }

    .neon-shell{
      position:relative;
      border-radius:26px;
      padding:1px;
      box-shadow: var(--shadow);
      margin-top:18px;
    }
    .neon-shell::before{
      content:"";
      position:absolute; inset:0;
      border-radius:26px;
      background: linear-gradient(90deg, rgba(255,0,170,.65), rgba(0,200,255,.55), rgba(140,60,255,.65));
      filter: blur(12px);
      opacity:.55;
      pointer-events:none;
    }
    .card{
      position:relative;
      border-radius:26px;
      background: rgba(255,255,255,.05);
      backdrop-filter: blur(14px);
      border:1px solid rgba(255,255,255,.12);
    }

    .grid4{
      display:grid;
      grid-template-columns: repeat(1, minmax(0,1fr));
      gap:12px;
      padding:18px;
    }
    @media (min-width: 640px){ .grid4{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    @media (min-width: 980px){ .grid4{ grid-template-columns: repeat(4, minmax(0,1fr)); } }

    .person-btn{
      position:relative;
      overflow:hidden;
      border-radius:18px;
      padding:18px 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      text-align:left;
    }
    .person-btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.18);
    }
    .person-btn::after{
      content:"";
      position:absolute; inset:-40px;
      background: radial-gradient(circle at 20% 30%, rgba(255,0,170,.22), transparent 55%),
                  radial-gradient(circle at 80% 40%, rgba(0,200,255,.16), transparent 55%),
                  radial-gradient(circle at 60% 80%, rgba(140,60,255,.16), transparent 55%);
      opacity:0;
      transition: opacity .18s ease;
      pointer-events:none;
    }
    .person-btn:hover::after{ opacity:1; }

    .person-title{ font-weight:800; font-size:18px; }
    .person-sub{ margin-top:6px; color:var(--muted2); font-size:13px; }

    .topbar{
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:center; justify-content:space-between;
      margin: 10px 0 16px;
    }
    .back{
      color:rgba(255,255,255,.72);
      text-decoration:none;
      cursor:pointer;
      border:none;
      background:transparent;
      padding:8px 0;
    }
    .back:hover{ color:#fff; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
    }
    .pill strong{ font-weight:800; }
    .action{
      padding:11px 14px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      transition: background .15s ease, transform .15s ease;
    }
    .action:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .action:focus{ outline: 2px solid rgba(0,200,255,.45); outline-offset:2px; }

    .cats{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:16px;
    }
    @media (min-width: 980px){ .cats{ grid-template-columns: 1fr 1fr; } }

    .cat{
      position:relative;
      border-radius:22px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding:14px;
    }
    .cat h2{ margin:0; font-size:16px; font-weight:800; }
    .cat .status{ margin-top:6px; font-size:12px; color:var(--muted2); }
    .status.on{ color: rgba(140,255,255,.88); }
    .cat-head{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:flex-start;
      margin-bottom:10px;
    }
    .mini{
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      cursor:pointer;
      font-size:12px;
    }
    .mini:hover{ background: rgba(0,0,0,.30); }

    .list{ display:flex; flex-direction:column; gap:8px; }
    .row{
      display:flex; align-items:center; gap:10px;
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      transition: background .15s ease, border-color .15s ease, transform .12s ease;
    }
    .row.drag-enabled:hover{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.18);
    }
    .row.dragging{
      opacity:.85;
      transform: scale(1.01);
      outline: 2px solid rgba(0,200,255,.45);
      outline-offset: 2px;
    }
    .handle{
      width:36px; height:36px;
      border-radius:14px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      user-select:none;
      cursor: default;
      color: rgba(255,255,255,.70);
    }
    .row.drag-enabled .handle{ cursor: grab; }
    .row.drag-enabled .handle:active{ cursor: grabbing; }
    .handle.off{ color: rgba(255,255,255,.35); }

    .num{
      width:38px;
      text-align:center;
      color: rgba(255,255,255,.50);
      font-variant-numeric: tabular-nums;
      font-size:12px;
    }

    
    .score{
      width:70px;
      display:flex;
      justify-content:flex-end;
      margin-left:10px;
    }
    .score .badge{
      min-width:48px;
      text-align:center;
      padding:9px 12px;
      border-radius:999px;
      font-weight:800;
      letter-spacing:.02em;
      font-size:13px;
      font-variant-numeric: tabular-nums;
      color:#fff;
      background:
        radial-gradient(circle at top left, rgba(255,255,255,.35), transparent 40%),
        linear-gradient(135deg, rgba(255,0,170,.85), rgba(0,200,255,.85));
      box-shadow:
        0 0 10px rgba(255,0,170,.55),
        0 0 22px rgba(0,200,255,.45),
        inset 0 0 8px rgba(255,255,255,.35);
      animation: scorePulse 2.4s ease-in-out infinite;
    }

    .row.dragging .score .badge{
      animation: scoreDrag 1s ease-in-out infinite;
    }

    @keyframes scorePulse{
      0%,100%{
        box-shadow:
          0 0 10px rgba(255,0,170,.55),
          0 0 22px rgba(0,200,255,.45),
          inset 0 0 8px rgba(255,255,255,.35);
        transform: scale(1);
      }
      50%{
        box-shadow:
          0 0 16px rgba(255,0,170,.9),
          0 0 34px rgba(0,200,255,.85),
          inset 0 0 10px rgba(255,255,255,.45);
        transform: scale(1.08);
      }
    }

    @keyframes scoreDrag{
      0%,100%{ transform: scale(1.05) rotate(-1deg); }
      50%{ transform: scale(1.15) rotate(1deg); }
    }


    input.text{
      width:100%;
      flex:1;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      padding:10px 12px;
      color:#fff;
      outline:none;
    }
    input.text::placeholder{ color: rgba(255,255,255,.35); }
    input.text:focus{
      border-color: transparent;
      box-shadow: 0 0 0 2px rgba(255,0,170,.35);
    }

    .grid-bg{
      height:240px;
      margin-top:18px;
      border-radius:26px;
      opacity:.12;
      background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.15) 1px, transparent 0);
      background-size: 22px 22px;
    }

    .hint{
      margin-top:14px;
      color: rgba(255,255,255,.45);
      font-size:12px;
      padding: 0 2px;
    }


    /* --- Stats view (James Rigas) --- */
    .stats-wrap{
      padding:16px;
    }
    .stats-note{
      margin: 8px 0 0;
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.35;
    }
    .stats-table{
      width:100%;
      border-collapse: collapse;
      font-size: 13px;
      overflow:hidden;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    .stats-table th,
    .stats-table td{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      vertical-align: top;
      text-align:left;
      white-space: nowrap;
    }
    .stats-table th{
      position: sticky;
      top: 0;
      background: rgba(0,0,0,.40);
      backdrop-filter: blur(10px);
      z-index: 2;
      font-weight: 800;
    }
    .stats-table td.numcell, .stats-table th.numcell{ text-align:right; }
    .stats-table tr:last-child td{ border-bottom:none; }
    .stats-cat-row td{
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: .02em;
      background: rgba(255,255,255,.06);
      white-space: normal;
    }
    .stats-song{
      white-space: normal;
      max-width: 520px;
    }
    .stats-scroll{
      max-height: 70vh;
      overflow:auto;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 0 0 1px rgba(255,255,255,.02) inset;
    }

    .hidden{ display:none !important; }
  </style>
</head>

<body>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
  const firebaseConfig = {
    apiKey: "AIzaSyA3j74FN_DIrsZcLq0gU1Y62eenSOzPqyQ",
    authDomain: "euphoria-2026.firebaseapp.com",
    projectId: "euphoria-2026",
    storageBucket: "euphoria-2026.firebasestorage.app",
    messagingSenderId: "259023927428",
    appId: "1:259023927428:web:74099e69bea7b07a7b2ad1"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
</script>

  <div class="wrap">
    <div id="homeView">
      <div class="header">
        <div class="logo"></div>
        <div>
          <h1>Neon Awards Form</h1>
          <p class="subtitle">
            Διάλεξε άτομο. Κάθε σελίδα έχει 10 κατηγορίες με 10 γραμμές. Μόλις γεμίσουν όλες οι γραμμές
            μιας κατηγορίας, ενεργοποιείται drag & drop κατάταξη και μπαίνει αυτόματα score (12–1).
          </p>
        </div>
      </div>

      <div class="neon-shell">
        <div class="card">
          <div class="grid4" id="peopleGrid"></div>
        </div>
      </div>

      <div class="grid-bg"></div>
    </div>

    <div id="personView" class="hidden">
      <div class="topbar">
        <div>
          <button class="back" id="backBtn">← Πίσω</button>
          <div class="header" style="margin:6px 0 0;">
            <div class="logo" style="width:34px;height:34px;"></div>
            <div>
              <h1 id="personTitle" style="font-size: clamp(24px, 3.8vw, 38px); margin:0;"></h1>
              <p class="subtitle" style="margin-top:6px;">
                Συμπλήρωσε τις γραμμές. Όταν γεμίσουν και οι 10 σε μια κατηγορία, μπορείς να κάνεις drag & drop για κατάταξη
                και το score ενημερώνεται αυτόματα (1η=12, 2η=10, 3η=8, 4η=7, ... 10η=1).
              </p>
            </div>
          </div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <div class="pill" title="Autosave σε localStorage">
            <span>Autosave:</span> <strong>ON</strong>
          </div>
          <button class="action" id="resetAllBtn">Reset όλα</button>
          <button class="action" id="commitBtn" title="Αποθήκευση online (Firestore)">Καταχώρηση</button>
          <button class="action" id="syncExcelBtn" title="Συγχρονισμός από Excel">Sync Excel</button>
          <input type="file" id="excelFile" accept=".xlsx,.xls,.csv" style="display:none" />
        </div>
      </div>

      <div class="neon-shell">
        <div class="card">
          <div class="cats" id="categories"></div>
        </div>
      </div>

      <div class="hint">Tip: Το drag ενεργοποιείται ανά κατηγορία, μόνο όταν όλες οι 10 γραμμές είναι συμπληρωμένες. Το score αλλάζει αυτόματα με την κατάταξη.</div>

      </div>

    <div id="statsView" class="hidden">
      <div class="topbar">
        <div>
          <button class="back" id="statsBackBtn">← Πίσω</button>
          <div class="header" style="margin:6px 0 0;">
            <div class="logo" style="width:34px;height:34px;"></div>
            <div>
              <h1 style="font-size: clamp(24px, 3.8vw, 38px); margin:0;">Στατιστικά (Όλοι οι χρήστες)</h1>
              <p class="stats-note">
                Σύνολο πόντων ανά τραγούδι/υποψηφιότητα: 1η=12, 2η=10, 3η=8, 4η=7, ... 10η=1. Τα κενά πεδία αγνοούνται.
              </p>
            </div>
          </div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="action" id="refreshStatsBtn" title="Επαναϋπολογισμός από τα αποθηκευμένα δεδομένα">Refresh</button>
        </div>
      </div>

      <div class="neon-shell">
        <div class="card stats-wrap">
          <div class="stats-scroll">
            <table class="stats-table" id="statsTable"></table>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<!-- Firebase SDKs (Firestore) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
  // Firebase config (Euphoria 2026)
  const firebaseConfig = {
    apiKey: "AIzaSyA3j74FN_DIrsZcLq0gU1Y62eenSOzPqyQ",
    authDomain: "euphoria-2026.firebaseapp.com",
    projectId: "euphoria-2026",
    storageBucket: "euphoria-2026.firebasestorage.app",
    messagingSenderId: "259023927428",
    appId: "1:259023927428:web:74099e69bea7b07a7b2ad1"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
</script>

<script>
(() => {
  const PEOPLE = [
    { label: "James Rigas", slug: "james-rigas" },
    { label: "Teri Vi Sentio", slug: "teri-vi-sentio" },
    { label: "Monhia", slug: "monhia" },
    { label: "Lisjansi", slug: "lisjansi" },
  ];

  const NON_VOTING_SLUGS = new Set(["james-rigas"]);

  // --- Simple passcode gate (session-based) ---
  // Passcodes per section/user:
  // James Rigas (stats): 0825
  // Teri Vi Sentio: 1478
  // Monhia: 9632
  // Lisjansi: 2365
  const PASSCODES = {
    "stats": "0825",
    "teri-vi-sentio": "1478",
    "monhia": "9632",
    "lisjansi": "2365",
  };

  function sessionKey(target){ return `neon-awards:auth:${target}`; }

  function isAuthed(target){
    try{ return sessionStorage.getItem(sessionKey(target)) === "1"; }catch{ return false; }
  }

  function setAuthed(target){
    try{ sessionStorage.setItem(sessionKey(target), "1"); }catch{}
  }

  function requirePasscode(target){
    const expected = PASSCODES[target];
    if (!expected) return true; // no gate
    if (isAuthed(target)) return true;

    const labelMap = {
      "stats": "James Rigas",
      "teri-vi-sentio": "Teri Vi Sentio",
      "monhia": "Monhia",
      "lisjansi": "Lisjansi",
    };
    const who = labelMap[target] || target;

    const entered = prompt(`Κωδικός πρόσβασης για ${who}:`);
    if (entered === null) return false;

    if (String(entered).trim() === expected){
      setAuthed(target);
      return true;
    }
    alert("Λάθος κωδικός.");
    return false;
  }


  const CATEGORIES = [
    "Best gr song",
    "Best foreign song",
    "Best GR Male Artist",
    "Best GR Female Artsis",
    "Best Foreign Male Artist",
    "Best Foreign Female Artist",
    "Best GR music Video",
    "Best Foreign Music Video",
    "Best ESC 2025 perfomance",
    "Best Album of the Year",
  ];

  // Scoring for 10 items
  const SCORES = [12, 10, 8, 7, 6, 5, 4, 3, 2, 1];

  const qs = (sel, el=document) => el.querySelector(sel);

  const qsa = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  const norm = (s) => String(s ?? "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/[΄´’`]/g, "'");

  const normKey = (s) => norm(s)
    .replace(/[^a-z0-9α-ωάέήίόύώϊϋΐΰ ]/gi, "")
    .replace(/\s+/g, " ")
    .trim();

  function matchCategory(excelCat){
    const key = normKey(excelCat);
    if (!key) return null;

    // Aliases for common Excel labels (your export uses uppercase names)
    const ALIASES = {
      "best greek song": "Best gr song",
      "best foreign song": "Best foreign song",
      "best greek male artist": "Best GR Male Artist",
      "best greek female artist": "Best GR Female Artsis",
      "best foreign male artist": "Best Foreign Male Artist",
      "best foreign female artist": "Best Foreign Female Artist",
      "best greek music video": "Best GR music Video",
      "best foreign music video": "Best Foreign Music Video",
      "best esc 25 performance": "Best ESC 2025 perfomance",
      "best esc 2025 performance": "Best ESC 2025 perfomance",
      "best esc 25 perfomance": "Best ESC 2025 perfomance",
      "best esc 2025 perfomance": "Best ESC 2025 perfomance",
      "album of the year": "Best Album of the Year"
    };

    if (ALIASES[key]){
      return ALIASES[key];
    }

    // Exact match
    for (const cat of CATEGORIES){
      if (normKey(cat) === key) return cat;
    }

    // Loose match (contains)
    for (const cat of CATEGORIES){
      const ck = normKey(cat);
      if (ck.includes(key) || key.includes(ck)) return cat;
    }
    return null;
  }

  function findPersonSlug(header){
    const key = normKey(header);

    // Candidates: configured PEOPLE + any discovered users in storage (excluding non-voting)
    let candidates = [];
    try{
      candidates = getPeopleForStats(); // excludes NON_VOTING_SLUGS
    }catch{
      candidates = (typeof PEOPLE !== "undefined" ? PEOPLE : []);
    }

    // Exact match
    for (const p of candidates){
      if (normKey(p.label) === key) return p.slug;
    }
    // Loose match
    for (const p of candidates){
      const pk = normKey(p.label);
      if (!pk) continue;
      if (key.includes(pk) || pk.includes(key)) return p.slug;
    }
    return null;
  }

  const homeView = qs("#homeView");
  const personView = qs("#personView");
  const peopleGrid = qs("#peopleGrid");
  const categoriesEl = qs("#categories");
  const personTitle = qs("#personTitle");
  const backBtn = qs("#backBtn");
  const resetAllBtn = qs("#resetAllBtn");
  const syncExcelBtn = qs("#syncExcelBtn");
  const excelFile = qs("#excelFile");
  const commitBtn = qs("#commitBtn");

  // --- Online sync (Firestore) ---
  // We store only COMMITTED data online (after "Καταχώρηση").
  // Client-side passcodes protect access, but Firestore rules must allow your desired reads/writes.
  const ONLINE_COLLECTION = "submissions";

  // local editing guard: if user is typing, don't overwrite UI from remote changes
  let localDirty = false;

  // committed cache from Firestore (live)
  let committedCache = {}; // { [slug]: stateObject }

  function isVotingSlug(slug){
    return !!slug && !NON_VOTING_SLUGS.has(slug);
  }

  async function commitOnline(slug, st){
    if (!db) throw new Error("Firestore δεν είναι έτοιμο.");
    await db.collection(ONLINE_COLLECTION).doc(slug).set({
      committed: st,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }

  function getCommittedFor(slug){
    return committedCache?.[slug] || null;
  }

  function hydrateStateFromCommitted(slug){
    const remote = getCommittedFor(slug);
    if (!remote) return false;
    // normalize and ensure 10 rows
    const parsed = JSON.parse(JSON.stringify(remote));
    for (const cat of CATEGORIES){
      if (!Array.isArray(parsed?.[cat])) parsed[cat] = [];
      parsed[cat] = parsed[cat].map((r,i) => ({
        id: String(r?.id || `${cat}__${i}__${uuid()}`),
        text: String(r?.text || "")
      }));
      if (parsed[cat].length < 10){
        const start = parsed[cat].length;
        for (let i=start; i<10; i++){
          parsed[cat].push({ id: `${cat}__${i}__${uuid()}`, text: "" });
        }
      } else if (parsed[cat].length > 10){
        parsed[cat] = parsed[cat].slice(0,10);
      }
    }
    state = parsed;
    // keep local copy too (optional cache)
    try{ localStorage.setItem(storageKey(slug), JSON.stringify(state)); }catch{}
    return true;
  }

  function startFirestoreLiveSync(){
    if (!db) return;
    db.collection(ONLINE_COLLECTION).onSnapshot((snap) => {
      const next = {};
      snap.forEach(doc => {
        const data = doc.data() || {};
        if (data.committed) next[doc.id] = data.committed;
      });
      committedCache = next;

      // If stats are visible, rerender live
      if (!statsView.classList.contains("hidden")){
        renderStats();
      }

      // If a person is open and not dirty, refresh from remote committed
      if (currentPerson && currentPerson.slug && isVotingSlug(currentPerson.slug) && !localDirty){
        if (hydrateStateFromCommitted(currentPerson.slug)){
          renderCategories();
        }
      }
    }, (err) => {
      console.error("Firestore onSnapshot error:", err);
    });
  }

  const statsView = qs("#statsView");
  const statsBackBtn = qs("#statsBackBtn");
  const refreshStatsBtn = qs("#refreshStatsBtn");
  const statsTable = qs("#statsTable");

  let currentPerson = null;
  let state = null; // { [category]: [ {id,text} x10 ] }
  let dragCtx = { cat: null, draggingId: null };

  function storageKey(slug){ return `neon-awards:${slug}`; }

  function slugToLabel(slug){
    return String(slug||"")
      .replace(/[-_]+/g," ")
      .replace(/\b\w/g, (m)=>m.toUpperCase());
  }

  function getPeopleForStats(){
    // Start with configured people (keeps order)
    const map = new Map();
    for (const p of PEOPLE) map.set(p.slug, { slug: p.slug, label: p.label });

    // Add any other users that exist in localStorage (created via Excel sync or future expansion)
    try{
      for (let i=0; i<localStorage.length; i++){
        const k = localStorage.key(i);
        if (!k || !k.startsWith("neon-awards:")) continue;
        const slug = k.slice("neon-awards:".length).trim();
        if (!slug) continue;
        if (!map.has(slug)) map.set(slug, { slug, label: slugToLabel(slug) });
      }
    }catch{}

    return Array.from(map.values()).filter(p => !NON_VOTING_SLUGS.has(p.slug));
  }

  function uuid() {
    if (crypto && crypto.randomUUID) return crypto.randomUUID();
    return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function makeDefaultState(){
    const obj = {};
    for (const cat of CATEGORIES){
      obj[cat] = Array.from({length:10}, (_,i) => ({ id: `${cat}__${i}__${uuid()}`, text: "" }));
    }
    return obj;
  }

  // --- Excel Sync helpers (imports songs per category per person column) ---
  function loadStateFor(slug){
    try{
      const raw = localStorage.getItem(storageKey(slug));
      if (!raw) return makeDefaultState();
      const parsed = JSON.parse(raw);
      for (const cat of CATEGORIES){
        if (!Array.isArray(parsed?.[cat])) parsed[cat] = [];
        parsed[cat] = parsed[cat].map((r,i) => ({
          id: String(r?.id || `${cat}__${i}__${uuid()}`),
          text: String(r?.text || "")
        }));
        if (parsed[cat].length < 10){
          const start = parsed[cat].length;
          for (let i=start; i<10; i++){
            parsed[cat].push({ id: `${cat}__${i}__${uuid()}`, text: "" });
          }
        }
      }
      return parsed;
    }catch{
      return makeDefaultState();
    }
  }

  function saveStateFor(slug, st){
    try{ localStorage.setItem(storageKey(slug), JSON.stringify(st)); }catch{}
  }

  function ensureRowsFor(st, cat, needed){
    const need = Math.max(10, Number(needed||0));
    if (!Array.isArray(st[cat])) st[cat] = [];
    while (st[cat].length < need){
      const i = st[cat].length;
      st[cat].push({ id: `${cat}__${i}__${uuid()}`, text: "" });
    }
  }

  function parseWorkbookToMatrix(workbook){
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    return XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });
  }


  function parseCSVToMatrix(csvText){
    // Simple CSV parser supporting commas/semicolons and quoted fields
    const text = String(csvText || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    const lines = text.split("\n").filter(l => l.length > 0);
    if (!lines.length) return [];

    // Detect delimiter
    const sample = lines.slice(0, 10).join("\n");
    const semi = (sample.match(/;/g) || []).length;
    const comma = (sample.match(/,/g) || []).length;
    const delim = semi > comma ? ";" : ",";

    const out = [];
    for (const line of lines){
      const row = [];
      let cur = "";
      let inQ = false;
      for (let i=0; i<line.length; i++){
        const ch = line[i];
        if (ch === '"'){
          if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if (!inQ && ch === delim){
          row.push(cur);
          cur = "";
        } else {
          cur += ch;
        }
      }
      row.push(cur);
      out.push(row.map(v => String(v ?? "").trim()));
    }
    return out;
  }

  function syncFromExcelMatrix(matrix){
    if (!Array.isArray(matrix) || matrix.length < 2){
      alert("Το Excel δεν έχει αρκετά δεδομένα.");
      return;
    }
    const headers = (matrix[0] || []).map(h => String(h ?? "").trim());

// Fallback: some exports (like yours) have empty person headers in row 1.
// If person headers are blank, map columns B.. to PEOPLE in order.
const personHeaderCount = headers.filter((h, idx) => idx !== 0 && String(h).trim().length).length;
if (personHeaderCount === 0){
  let p = 0;
  for (let i = 0; i < headers.length; i++){
    if (i === 0) continue; // category col candidate
    if (p < PEOPLE.length){
      headers[i] = PEOPLE[p].label;
      p++;
    }
  }
}
    const catColIdx = headers.findIndex(h => normKey(h) === "κατηγορία" || normKey(h) === "category");
    if (catColIdx === -1){
      alert("Δεν βρέθηκε στήλη 'Κατηγορία' στο Excel.");
      return;
    }

    // Map Excel columns -> person slug
    const colToSlug = {};
    headers.forEach((h, idx) => {
      if (idx === catColIdx) return;
      const slug = findPersonSlug(h);
      if (slug) colToSlug[idx] = slug;
    });
    const slugs = Array.from(new Set(Object.values(colToSlug)));
    if (!slugs.length){
      alert("Δεν βρέθηκαν στήλες ατόμων στο Excel (π.χ. Teri Vi Sentio, Monhia, Lisjansi).");
      return;
    }

    const collected = {};
    for (const slug of slugs) collected[slug] = {};

    let currentExcelCat = "";
    for (let r = 1; r < matrix.length; r++){
      const row = matrix[r] || [];
      const rawCat = String(row[catColIdx] ?? "").trim();
      if (rawCat) currentExcelCat = rawCat;

      const cat = matchCategory(currentExcelCat);
      if (!cat) continue;

      for (const [idxStr, slug] of Object.entries(colToSlug)){
        const c = Number(idxStr);
        const title = String(row[c] ?? "").trim();
        if (!title) continue;
        collected[slug][cat] ??= [];
        collected[slug][cat].push(title);
      }
    }

    // Apply to storage for each person column
    for (const slug of slugs){
      const st = loadStateFor(slug);

      for (const [cat, songs] of Object.entries(collected[slug])){
        ensureRowsFor(st, cat, songs.length);

        // clear existing
        for (let i = 0; i < st[cat].length; i++){
          st[cat][i].text = "";
        }

        // fill in order
        songs.forEach((t, i) => {
          ensureRowsFor(st, cat, i+1);
          st[cat][i].text = t;
        });
      }

      saveStateFor(slug, st);
    }

    // Refresh current UI if a person is open
    if (currentPerson && currentPerson.slug){
      state = loadState(currentPerson.slug);
      renderCategories();
    }

    alert("Έγινε συγχρονισμός από Excel ✅");
  }

  function handleExcelFile(file){
    if (!file) return;
    const name = String(file.name || "").toLowerCase();

    // CSV path (works offline)
    if (name.endsWith(".csv")){
      const reader = new FileReader();
      reader.onload = (evt) => {
        try{
          const text = String(evt.target.result || "");
          const matrix = parseCSVToMatrix(text);
          syncFromExcelMatrix(matrix);
          alert("Έγινε συγχρονισμός από CSV ✅");
        }catch(err){
          console.error(err);
          alert("Αποτυχία ανάγνωσης CSV.");
        } finally {
          if (excelFile) excelFile.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
      return;
    }

    // XLS/XLSX path (requires XLSX library)
    if (typeof XLSX === "undefined"){
      alert("Δεν φορτώθηκε η βιβλιοθήκη Excel (XLSX). Αν άνοιξες το HTML χωρίς internet ή ο browser μπλοκάρει τα CDN scripts, δεν μπορεί να διαβάσει .xlsx.\n\nΛύση: (1) άνοιξε το HTML με internet ή μέσω τοπικού server, ή (2) κάνε 'Αποθήκευση ως CSV (UTF-8)' και ανέβασέ το ως .csv.");
      if (excelFile) excelFile.value = "";
      return;
    }

    const reader = new FileReader();
    reader.onload = (evt) => {
      try{
        const result = evt && evt.target ? evt.target.result : null;

        // Safari/older browsers can be picky: prefer Uint8Array -> XLSX.read
        let wb = null;
        if (result instanceof ArrayBuffer){
          const u8 = new Uint8Array(result);
          wb = XLSX.read(u8, { type: "array" });
        } else if (result && result.byteLength !== undefined){
          const u8 = new Uint8Array(result);
          wb = XLSX.read(u8, { type: "array" });
        } else if (typeof result === "string"){
          // Fallback for .xls readAsBinaryString
          wb = XLSX.read(result, { type: "binary" });
        } else {
          throw new Error("Μη υποστηριζόμενος τύπος αρχείου από τον browser.");
        }

        const matrix = parseWorkbookToMatrix(wb);
        syncFromExcelMatrix(matrix);
      }catch(err){
        console.error(err);
        const msg = (err && err.message) ? err.message : String(err || "");
        alert("Αποτυχία ανάγνωσης Excel.\n" + msg);
      } finally {
        if (excelFile) excelFile.value = "";
      }
    };

    if (name.endsWith(".xls")){
      reader.readAsBinaryString(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  }


  function loadState(slug){
    return loadStateFor(slug);
  }

  function saveState(){
    try{
      localStorage.setItem(storageKey(currentPerson.slug), JSON.stringify(state));
    }catch{}
  }

  function isCategoryFilled(cat){
    return state[cat].every(r => (r.text || "").trim().length > 0);
  }

  function showHome(){
    currentPerson = null;
    state = null;
    personView.classList.add("hidden");
    statsView.classList.add("hidden");
    homeView.classList.remove("hidden");
    history.replaceState(null, "", location.pathname + location.search + "#/");
  }

  function showStats(){
    currentPerson = null;
    state = null;
    homeView.classList.add("hidden");
    personView.classList.add("hidden");
    statsView.classList.remove("hidden");
    renderStats();
    history.replaceState(null, "", location.pathname + location.search + "#/stats");
  }

  function computeStatsRows(people){
    // Prefer ONLINE committed data. If missing for a user, fallback to localStorage state.
    const allStates = {};
    for (const p of people){
      allStates[p.slug] = getCommittedFor(p.slug) || loadStateFor(p.slug);
    }

    const rows = [];
    for (const cat of CATEGORIES){
      const songMap = new Map();
      const catTotals = {};
      for (const p of people) catTotals[p.slug] = 0;

      for (const p of people){
        const list = Array.isArray(allStates[p.slug]?.[cat]) ? allStates[p.slug][cat] : [];
        for (let i=0; i<Math.min(10, list.length); i++){
          const txt = String(list[i]?.text || "").trim();
          if (!txt) continue;
          const key = normKey(txt);
          if (!key) continue;
          const score = Number(SCORES[i] || 0);

          if (!songMap.has(key)) songMap.set(key, { name: txt, per: {}, total: 0 });
          const entry = songMap.get(key);
          entry.per[p.slug] = (entry.per[p.slug] || 0) + score;
          entry.total += score;

          catTotals[p.slug] += score;
        }
      }

      const catTotalAll = Object.values(catTotals).reduce((a,b)=>a+b,0);

      const songs = Array.from(songMap.values()).sort((a,b) => {
        if (b.total !== a.total) return b.total - a.total;
        return a.name.localeCompare(b.name, "el");
      });

      rows.push({ type: "cat", label: cat, total: catTotalAll, per: catTotals });
      for (const s of songs){
        rows.push({ type: "song", label: s.name, total: s.total, per: s.per });
      }
    }
    return rows;
  }

  function renderStats(){
    if (!statsTable) return;

    const people = getPeopleForStats();
    const rows = computeStatsRows(people);
    const head = `
      <thead>
        <tr>
          <th>Κατηγορία / Τίτλος</th>
          <th class="numcell">total</th>
          ${people.map(p => `<th class="numcell">${escapeHtml(p.label)}</th>`).join("")}
        </tr>
      </thead>
    `;

    const body = rows.map(r => {
      const cells = people.map(p => {
        const v = Number(r.per?.[p.slug] || 0);
        return `<td class="numcell">${v}</td>`;
      }).join("");

      if (r.type === "cat"){
        return `
          <tr class="stats-cat-row">
            <td>${escapeHtml(r.label)}</td>
            <td class="numcell">${Number(r.total || 0)}</td>
            ${cells}
          </tr>
        `;
      }
      return `
        <tr>
          <td class="stats-song">${escapeHtml(r.label)}</td>
          <td class="numcell">${Number(r.total || 0)}</td>
          ${cells}
        </tr>
      `;
    }).join("");

    statsTable.innerHTML = head + `<tbody>${body}</tbody>`;
  }


  function showPerson(slug){
    const p = PEOPLE.find(x => x.slug === slug);
    if (!p) return showHome();
    currentPerson = p;
    state = loadState(slug);
    localDirty = false;
    // Prefer online committed (if available) so all browsers see the same
    if (isVotingSlug(slug)){
      try{ hydrateStateFromCommitted(slug); }catch{}
    }
    if (commitBtn){ commitBtn.classList.toggle('hidden', !isVotingSlug(slug)); }
    homeView.classList.add("hidden");
    statsView.classList.add("hidden");
    personView.classList.remove("hidden");
    personTitle.textContent = p.label;
    renderCategories();
    history.replaceState(null, "", location.pathname + location.search + "#/" + slug);
  }

  function renderHomeButtons(){
    peopleGrid.innerHTML = "";
    for (const p of PEOPLE){
      const btn = document.createElement("button");
      btn.className = "person-btn";
      btn.type = "button";
      btn.innerHTML = `
        <div class="person-title">${escapeHtml(p.label)}</div>
        <div class="person-sub">Άνοιγμα σελίδας</div>
      `;
      btn.addEventListener("click", () => {
        if (p.slug === "james-rigas"){
          if (!requirePasscode("stats")) return;
          return showStats();
        }
        if (!requirePasscode(p.slug)) return;
        return showPerson(p.slug);
      });
      peopleGrid.appendChild(btn);
    }
  }

  function renderCategories(){
    categoriesEl.innerHTML = "";
    for (const cat of CATEGORIES){
      const filled = isCategoryFilled(cat);

      const catCard = document.createElement("div");
      catCard.className = "cat";
      catCard.dataset.cat = cat;

      const head = document.createElement("div");
      head.className = "cat-head";
      head.innerHTML = `
        <div>
          <h2>${escapeHtml(cat)}</h2>
          <div class="status ${filled ? "on" : ""}">
            ${filled ? "Drag & drop: ON" : "Drag & drop: OFF (γέμισε όλες τις γραμμές)"}
          </div>
        </div>
      `;
      const clearBtn = document.createElement("button");
      clearBtn.className = "mini";
      clearBtn.type = "button";
      clearBtn.textContent = "Clear";
      clearBtn.title = "Καθάρισμα μόνο αυτής της κατηγορίας";
      clearBtn.addEventListener("click", () => {
        state[cat] = state[cat].map(r => ({...r, text:""}));
        saveState();
        renderCategories();
      });
      head.appendChild(clearBtn);

      const list = document.createElement("div");
      list.className = "list";
      list.dataset.cat = cat;

      // rows
      state[cat].forEach((row, idx) => {
        const rowEl = document.createElement("div");
        rowEl.className = "row" + (filled ? " drag-enabled" : "");
        rowEl.dataset.id = row.id;
        rowEl.draggable = filled; // only enable drag when filled

        const handle = document.createElement("div");
        handle.className = "handle" + (filled ? "" : " off");
        handle.textContent = "☰";
        handle.title = filled ? "Drag" : "Συμπλήρωσε όλες τις γραμμές για να ενεργοποιηθεί το drag & drop";

        const num = document.createElement("div");
        num.className = "num";
        num.textContent = String(idx + 1);

        const score = document.createElement("div");
        score.className = "score";
        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = String(SCORES[idx] ?? "");
        score.appendChild(badge);

        const input = document.createElement("input");
        input.className = "text";
        input.type = "text";
        input.placeholder = "Γράψε εδώ...";
        input.value = row.text || "";
        input.addEventListener("input", (e) => {
          row.text = e.target.value;
          localDirty = true;
          saveState();

          // update only this category's drag enablement & status if it flips
          const nowFilled = isCategoryFilled(cat);
          if (nowFilled !== filled){
            renderCategories();
          }
        });

        // Drag & Drop events
        rowEl.addEventListener("dragstart", (e) => {
          if (!isCategoryFilled(cat)) { e.preventDefault(); return; }
          dragCtx.cat = cat;
          dragCtx.draggingId = row.id;
          rowEl.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", row.id);
        });
        rowEl.addEventListener("dragend", () => {
          rowEl.classList.remove("dragging");
          dragCtx.cat = null;
          dragCtx.draggingId = null;
        });
        rowEl.addEventListener("dragover", (e) => {
          if (!isCategoryFilled(cat)) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        });
        rowEl.addEventListener("drop", (e) => {
          if (!isCategoryFilled(cat)) return;
          e.preventDefault();
          const fromId = e.dataTransfer.getData("text/plain");
          const toId = row.id;
          if (!fromId || fromId === toId) return;
          if (dragCtx.cat !== cat) return;

          const arr = state[cat];
          const fromIdx = arr.findIndex(x => x.id === fromId);
          const toIdx = arr.findIndex(x => x.id === toId);
          if (fromIdx < 0 || toIdx < 0) return;

          // move
          const [item] = arr.splice(fromIdx, 1);
          arr.splice(toIdx, 0, item);

          saveState();
          // rerender: updates numbering + score badges
          renderCategories();
        });

        rowEl.appendChild(handle);
        rowEl.appendChild(num);
        rowEl.appendChild(input);
        rowEl.appendChild(score);
        list.appendChild(rowEl);
      });

      catCard.appendChild(head);
      catCard.appendChild(list);
      categoriesEl.appendChild(catCard);
    }
  }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // navigation
  // Commit (online) button
  if (commitBtn){
    commitBtn.addEventListener("click", async () => {
      if (!currentPerson || !currentPerson.slug) return;
      const slug = currentPerson.slug;
      if (!isVotingSlug(slug)) return;
      try{
        // save locally too (draft)
        saveState();
        await commitOnline(slug, state);
        localDirty = false;
        alert("Καταχωρήθηκε online ✅");
      }catch(err){
        console.error(err);
        alert("Αποτυχία online καταχώρησης.
" + (err?.message || err));
      }
    });
  }


  backBtn.addEventListener("click", showHome);
  if (statsBackBtn) statsBackBtn.addEventListener("click", showHome);
  if (refreshStatsBtn) refreshStatsBtn.addEventListener("click", renderStats);
  
  if (syncExcelBtn && excelFile){
    syncExcelBtn.addEventListener("click", () => excelFile.click());
    excelFile.addEventListener("change", (e) => handleExcelFile(e.target.files?.[0]));
  }

  resetAllBtn.addEventListener("click", () => {
    if (!currentPerson) return;
    state = makeDefaultState();
    saveState();
    renderCategories();
  });

  // hash routing: "#/slug" or "#/"
  function route(){
    const h = location.hash || "#/";
    const parts = h.replace(/^#\/?/, "").split("/").filter(Boolean);
    if (parts.length === 0) return showHome();
    if (parts[0] === "stats"){
      if (!requirePasscode("stats")) return showHome();
      return showStats();
    }
    const slug = parts[0];
    if (!requirePasscode(slug)) return showHome();
    return showPerson(slug);
  }

  window.addEventListener("hashchange", route);

  // init
  renderHomeButtons();
  startFirestoreLiveSync();
  route();
})();
</script>
</body>
</html>
